# 인테리봇 성향분석 엔진 업그레이드 비교 분석서

## 📋 목차
1. [현재 구조 vs 명세서 요구사항 비교](#1-현재-구조-vs-명세서-요구사항-비교)
2. [적용 후 예상 변화](#2-적용-후-예상-변화)
3. [장단점 점수표](#3-장단점-점수표)
4. [권장 사항](#4-권장-사항)

---

## 1. 현재 구조 vs 명세서 요구사항 비교

### 1-1. 입력/출력 구조

| 항목 | 현재 구조 | 명세서 요구사항 | 일치도 |
|------|----------|----------------|--------|
| **입력** | `DecisionImpactInput`<br>- scores<br>- evidenceCounts<br>- spaceInfo?<br>- discomfortDetail? | `DecisionImpactInput`<br>- traits: Record<PreferenceCategory, TraitEvaluation><br>- spaceInfo?<br>- discomfortDetail? | ⚠️ **부분 일치**<br>명세서는 TraitEvaluation을 직접 받지만,<br>현재는 scores/evidenceCounts를 받아 내부에서 생성 |
| **출력** | `DecisionImpactOutput`<br>- decisionSummary<br>- traitEvaluations | `DecisionImpactOutput`<br>- coreCriteria<br>- appliedChanges<br>- excludedItems<br>- risks | ✅ **일치**<br>decisionSummary 내부에 명세서 요구사항 포함 |

**차이점 분석:**
- 현재 구조는 `scores`와 `evidenceCounts`를 받아 내부에서 `TraitEvaluation`을 생성
- 명세서는 이미 생성된 `TraitEvaluation`을 직접 받음
- **영향도:** 낮음 (내부 변환만 하면 됨)

---

### 1-2. STEP 2-1: TraitEvaluation 정규화

| 항목 | 현재 구조 | 명세서 요구사항 | 일치도 |
|------|----------|----------------|--------|
| **검증** | `createTraitEvaluations()` 함수로 모든 카테고리 생성<br>누락 시 기본값(score: 5, evidenceCount: 0) 사용 | 모든 성향 카테고리에 대해 TraitEvaluation 존재 여부 확인<br>누락 시 즉시 FAIL | ⚠️ **부분 일치**<br>현재는 기본값으로 채우지만,<br>명세서는 FAIL 요구 |

**차이점 분석:**
- 현재: 누락 시 기본값으로 채움 (에러 없음)
- 명세서: 누락 시 즉시 FAIL (데이터 무결성 강화)
- **영향도:** 중간 (에러 처리 방식 변경 필요)

---

### 1-3. STEP 2-2: traitImpactMap 룰 로딩

| 항목 | 현재 구조 | 명세서 요구사항 | 일치도 |
|------|----------|----------------|--------|
| **검증** | `validateTraitImpactMap()` 호출<br>priorityGroup 누락 검증 | priorityGroup 확인<br>HIGH/LOW 룰 존재 여부 확인<br>priorityGroup 누락 → 즉시 FAIL | ✅ **일치**<br>현재 구조가 명세서 요구사항 충족 |

**차이점 분석:**
- 현재 구조가 명세서 요구사항을 완전히 충족
- **영향도:** 없음

---

### 1-4. STEP 2-3: 적용 후보 룰 수집

| 항목 | 현재 구조 | 명세서 요구사항 | 일치도 |
|------|----------|----------------|--------|
| **필터링** | `isDisabledTrait()` 체크 후<br>HIGH/LOW 레벨에 맞는 룰 선택<br>null 룰은 건너뛰기 | `trait.level === 'HIGH'`<br>`&& traitImpactRule !== null`<br>MID, LOW는 결정 변화 생성 금지 | ⚠️ **부분 일치**<br>현재는 LOW도 처리하지만,<br>명세서는 HIGH만 허용 |

**차이점 분석:**
- 현재: HIGH와 LOW 모두 처리
- 명세서: HIGH만 처리 (MID, LOW는 결정 변화 생성 금지)
- **영향도:** 높음 (LOW 처리 로직 제거 필요)

---

### 1-5. STEP 2-4: 우선순위 그룹 기준 정렬

| 항목 | 현재 구조 | 명세서 요구사항 | 일치도 |
|------|----------|----------------|--------|
| **정렬 기준** | 1. priorityGroup 순서<br>2. 같은 그룹이면 HIGH 레벨 우선 | 1. priorityGroup 순서<br>2. 동일 그룹 내에서는 evidenceCount 높은 순<br>3. 그래도 동일하면 정의 순서 유지 | ⚠️ **부분 일치**<br>현재는 레벨 기준 정렬,<br>명세서는 evidenceCount 기준 |

**차이점 분석:**
- 현재: priorityGroup → level (HIGH 우선)
- 명세서: priorityGroup → evidenceCount (높은 순) → 정의 순서
- **영향도:** 중간 (정렬 로직 수정 필요)

---

### 1-6. 공정 강제 판단 로직

| 항목 | 현재 구조 | 명세서 요구사항 | 일치도 |
|------|----------|----------------|--------|
| **검사 시점** | `applyRule()` 내부에서<br>`canForceProcess()` 호출 | `forceProcess === true`일 때<br>`canForceProcess` 검사<br>실패 시 processIncludes/Excludes 무시 | ✅ **일치**<br>현재 구조가 명세서 요구사항 충족 |

**차이점 분석:**
- 현재 구조가 명세서 요구사항을 완전히 충족
- **영향도:** 없음

---

### 1-7. 충돌 해결 규칙

| 항목 | 현재 구조 | 명세서 요구사항 | 일치도 |
|------|----------|----------------|--------|
| **해결 순서** | 1. 우선순위 그룹 비교<br>2. `isHigherPriority()` 사용 | 1. 우선순위 그룹이 높은 쪽 승리<br>2. 동일 그룹이면 evidenceCount 높은 쪽 승리<br>3. 그래도 동일하면 exclude가 default보다 우선 | ⚠️ **부분 일치**<br>현재는 evidenceCount 비교 없음<br>exclude 우선 규칙 없음 |

**차이점 분석:**
- 현재: priorityGroup만 비교
- 명세서: priorityGroup → evidenceCount → exclude 우선
- **영향도:** 중간 (충돌 해결 로직 보강 필요)

---

### 1-8. 증폭 인자 적용 시점

| 항목 | 현재 구조 | 명세서 요구사항 | 일치도 |
|------|----------|----------------|--------|
| **적용 위치** | 충돌 해결 후<br>결정 요약 생성 후 | 충돌 해결이 끝난 후<br>공정 강제 판단 이후<br>appliedChanges 문장 생성 직전 | ⚠️ **부분 일치**<br>현재는 결정 요약 생성 후 적용,<br>명세서는 appliedChanges 생성 직전 |

**차이점 분석:**
- 현재: `generateDecisionSummary()` 후 적용
- 명세서: `appliedChanges` 생성 직전 적용
- **영향도:** 낮음 (순서만 조정)

---

### 1-9. 결과 합성 (고객 노출 기준)

| 항목 | 현재 구조 | 명세서 요구사항 | 일치도 |
|------|----------|----------------|--------|
| **coreCriteria** | 상위 3개 카테고리 선택<br>카테고리 이름 그대로 사용 | priorityGroup 상위에서 2~3개<br>추상 단어 ❌<br>"결정 기준" 문장으로 생성 | ⚠️ **부분 일치**<br>현재는 카테고리 이름만,<br>명세서는 문장화 필요 |
| **appliedChanges** | "공정 포함: ..." 형식<br>코드 그대로 노출 | 공정/옵션 이름 그대로 ❌<br>"그래서 무엇이 달라졌는지" 문장화 | ⚠️ **부분 일치**<br>현재는 코드 노출,<br>명세서는 사람이 읽는 문장 필요 |
| **excludedItems** | 제외된 옵션/공정 나열<br>가정 항목 포함 | 최소 1개 이상 필수<br>가정/제외/미포함 항목 명시 | ✅ **일치**<br>현재 구조가 명세서 요구사항 충족 |
| **risks** | riskMessages 슬라이스 (최대 3개) | 1~3개<br>조건 기반<br>겁주기 금지 | ✅ **일치**<br>현재 구조가 명세서 요구사항 충족 |

**차이점 분석:**
- coreCriteria: 카테고리 이름 → "결정 기준" 문장화 필요
- appliedChanges: 코드 노출 → 사람이 읽는 문장으로 변환 필요
- **영향도:** 높음 (문장 생성 로직 추가 필요)

---

### 1-10. FAIL / 재질문 트리거 규칙

| 항목 | 현재 구조 | 명세서 요구사항 | 일치도 |
|------|----------|----------------|--------|
| **즉시 FAIL** | 단독 영향 폐기 성향이 결정 생성 시도 시 FAIL<br>appliedChanges/risks 빈 배열 시 경고만 | appliedChanges가 비어 있음<br>priorityGroup 누락<br>단독 영향 폐기 성향이 결정 생성 시도 | ⚠️ **부분 일치**<br>현재는 경고만,<br>명세서는 FAIL 요구 |
| **재질문 트리거** | evidenceCount 낮을 때 경고만 | evidenceCount 평균 < 1.5<br>HIGH 성향 다수인데 canForceProcess 전부 실패<br>→ 결정 검증 질문 1~2개 생성 | ❌ **미구현**<br>재질문 트리거 로직 없음 |

**차이점 분석:**
- 현재: 경고만 출력
- 명세서: FAIL 또는 재질문 트리거 필요
- **영향도:** 중간 (에러 처리 및 재질문 로직 추가 필요)

---

## 2. 적용 후 예상 변화

### 2-1. 코드 변경 사항

#### ✅ 변경 불필요 (이미 명세서 요구사항 충족)
- `traitImpactMap` 룰 로딩 검증
- 공정 강제 판단 로직 (`canForceProcess`)
- `excludedItems` 생성 규칙
- `risks` 생성 규칙

#### ⚠️ 수정 필요 (명세서 요구사항과 차이)
1. **입력 구조 변경**
   - 현재: `scores`, `evidenceCounts` 받음
   - 변경: `traits: Record<PreferenceCategory, TraitEvaluation>` 받도록 수정
   - 또는: 내부 변환만 하고 인터페이스 유지 (권장)

2. **TraitEvaluation 정규화 강화**
   - 누락 시 기본값 대신 FAIL 처리
   - 모든 카테고리 존재 여부 엄격 검증

3. **적용 후보 룰 필터링**
   - LOW 레벨 처리 제거
   - HIGH만 처리하도록 수정

4. **정렬 로직 변경**
   - 현재: priorityGroup → level
   - 변경: priorityGroup → evidenceCount (내림차순) → 정의 순서

5. **충돌 해결 로직 보강**
   - evidenceCount 비교 추가
   - exclude 우선 규칙 추가

6. **증폭 인자 적용 시점 조정**
   - `appliedChanges` 생성 직전으로 이동

7. **결과 합성 개선**
   - `coreCriteria`: 카테고리 이름 → "결정 기준" 문장화
   - `appliedChanges`: 코드 → 사람이 읽는 문장으로 변환

8. **FAIL/재질문 트리거 구현**
   - `appliedChanges` 빈 배열 시 FAIL 처리
   - 재질문 트리거 로직 추가

---

### 2-2. 기능적 변화

#### ✅ 개선되는 점
1. **결정 일관성 향상**
   - evidenceCount 기반 정렬로 더 신뢰성 있는 결정
   - exclude 우선 규칙으로 보수적 판단 강화

2. **고객 경험 개선**
   - 코드 대신 사람이 읽는 문장으로 결과 제공
   - "왜 이렇게 됐는지" 자연스럽게 드러남

3. **데이터 무결성 강화**
   - 누락 시 FAIL 처리로 오류 조기 발견
   - 재질문 트리거로 불완전한 입력 보완

#### ⚠️ 주의할 점
1. **LOW 레벨 처리 제거**
   - 기존에 LOW로 처리하던 케이스가 무시됨
   - 영향도 확인 필요

2. **FAIL 처리 강화**
   - 기존에는 경고만 하던 케이스가 FAIL로 변경
   - 상위 레이어에서 에러 처리 필요

3. **문장 생성 로직 추가**
   - 코드 → 문장 변환 로직 필요
   - 번역 테이블 또는 템플릿 필요

---

## 3. 장단점 점수표

### 3-1. 현재 구조 평가

| 평가 항목 | 점수 (10점 만점) | 평가 근거 |
|----------|-----------------|----------|
| **명세서 준수도** | 6.5/10 | 핵심 로직은 구현되어 있으나, 세부 요구사항과 차이 있음 |
| **결정 일관성** | 7/10 | 우선순위 그룹 기반 충돌 해결은 있으나, evidenceCount 미반영 |
| **고객 경험** | 5/10 | 코드 그대로 노출, 문장화 부족 |
| **데이터 무결성** | 6/10 | 기본값으로 채우는 방식으로 오류 은폐 가능성 |
| **유지보수성** | 8/10 | 코드 구조가 명확하고 모듈화 잘 되어 있음 |
| **확장성** | 7/10 | 새로운 성향 추가 용이, 하지만 정렬/충돌 로직 수정 필요 |
| **성능** | 9/10 | 단순 루프와 Set 연산으로 효율적 |
| **테스트 용이성** | 7/10 | 함수 분리가 잘 되어 있으나, FAIL 케이스 테스트 부족 |

**종합 점수: 6.9/10**

---

### 3-2. 명세서 적용 후 예상 평가

| 평가 항목 | 점수 (10점 만점) | 평가 근거 |
|----------|-----------------|----------|
| **명세서 준수도** | 9.5/10 | 명세서 요구사항 거의 완전 충족 |
| **결정 일관성** | 9/10 | evidenceCount 기반 정렬 + exclude 우선으로 일관성 크게 향상 |
| **고객 경험** | 9/10 | 사람이 읽는 문장으로 결과 제공, "왜"가 자연스럽게 드러남 |
| **데이터 무결성** | 9/10 | FAIL 처리 강화로 오류 조기 발견, 재질문 트리거로 보완 |
| **유지보수성** | 8/10 | 문장 생성 로직 추가로 복잡도 약간 증가, 하지만 구조는 유지 |
| **확장성** | 8/10 | 새로운 성향 추가 시 문장 생성 로직도 함께 추가 필요 |
| **성능** | 8.5/10 | 문장 생성 로직 추가로 약간 느려질 수 있으나, 큰 영향 없음 |
| **테스트 용이성** | 8/10 | FAIL 케이스와 재질문 트리거 테스트 추가 필요 |

**종합 점수: 8.6/10**

---

### 3-3. 개선 효과 비교

| 항목 | 현재 | 적용 후 | 개선도 |
|------|------|---------|--------|
| **명세서 준수도** | 6.5 | 9.5 | +3.0 (46% 향상) |
| **결정 일관성** | 7.0 | 9.0 | +2.0 (29% 향상) |
| **고객 경험** | 5.0 | 9.0 | +4.0 (80% 향상) |
| **데이터 무결성** | 6.0 | 9.0 | +3.0 (50% 향상) |
| **유지보수성** | 8.0 | 8.0 | 0 (유지) |
| **확장성** | 7.0 | 8.0 | +1.0 (14% 향상) |
| **성능** | 9.0 | 8.5 | -0.5 (5% 하락, 무시 가능) |
| **테스트 용이성** | 7.0 | 8.0 | +1.0 (14% 향상) |

**평균 개선도: +1.7점 (24% 향상)**

---

### 3-4. 리스크 평가

| 리스크 항목 | 발생 가능성 | 영향도 | 대응 방안 |
|------------|-----------|--------|----------|
| **LOW 레벨 처리 제거로 인한 기능 누락** | 중간 | 중간 | LOW 레벨 케이스 테스트 후, 필요 시 예외 처리 추가 |
| **FAIL 처리 강화로 인한 에러 증가** | 높음 | 낮음 | 상위 레이어에서 에러 처리 및 재질문 트리거 구현 |
| **문장 생성 로직 버그** | 중간 | 높음 | 번역 테이블 검증 및 단위 테스트 강화 |
| **성능 저하** | 낮음 | 낮음 | 문장 생성 로직 최적화 (캐싱 등) |
| **기존 코드와의 호환성 문제** | 낮음 | 중간 | 점진적 마이그레이션 및 버전 관리 |

---

## 4. 권장 사항

### 4-1. 적용 우선순위

#### 🔴 높은 우선순위 (즉시 적용 권장)
1. **결과 합성 개선** (coreCriteria, appliedChanges 문장화)
   - 고객 경험에 직접적 영향
   - 구현 난이도: 중간

2. **적용 후보 룰 필터링** (HIGH만 처리)
   - 명세서 핵심 요구사항
   - 구현 난이도: 낮음

3. **정렬 로직 변경** (evidenceCount 기준)
   - 결정 일관성 향상
   - 구현 난이도: 낮음

#### 🟡 중간 우선순위 (단계적 적용)
4. **충돌 해결 로직 보강** (evidenceCount + exclude 우선)
   - 결정 일관성 향상
   - 구현 난이도: 중간

5. **FAIL/재질문 트리거 구현**
   - 데이터 무결성 강화
   - 구현 난이도: 높음 (상위 레이어 연동 필요)

#### 🟢 낮은 우선순위 (선택적 적용)
6. **입력 구조 변경**
   - 내부 변환만 하고 인터페이스 유지 권장
   - 구현 난이도: 낮음

7. **증폭 인자 적용 시점 조정**
   - 현재도 동작하므로 우선순위 낮음
   - 구현 난이도: 낮음

---

### 4-2. 구현 전략

#### Phase 1: 핵심 개선 (1-2주)
- 적용 후보 룰 필터링 (HIGH만)
- 정렬 로직 변경 (evidenceCount)
- 결과 합성 개선 (문장화)

#### Phase 2: 안정화 (1주)
- 충돌 해결 로직 보강
- 단위 테스트 강화
- 통합 테스트

#### Phase 3: 고도화 (1-2주)
- FAIL/재질문 트리거 구현
- TraitEvaluation 정규화 강화
- 성능 최적화

---

### 4-3. 주의사항

1. **기존 데이터 호환성**
   - LOW 레벨로 처리하던 케이스 확인 필요
   - 마이그레이션 전략 수립

2. **문장 생성 로직**
   - 번역 테이블 또는 템플릿 필요
   - A/B 테스트로 고객 반응 확인

3. **에러 처리**
   - FAIL 처리 강화에 따른 상위 레이어 대응 필요
   - 재질문 트리거 UI/UX 설계

4. **테스트 커버리지**
   - 새로운 로직에 대한 단위 테스트 필수
   - 엣지 케이스 테스트 강화

---

## 5. 결론

### 5-1. 종합 평가

현재 구조는 **명세서의 핵심 로직을 대부분 구현**하고 있으나, **세부 요구사항과 차이**가 있습니다.

**적용 후 예상 효과:**
- 명세서 준수도: 6.5 → 9.5 (+46%)
- 고객 경험: 5.0 → 9.0 (+80%)
- 결정 일관성: 7.0 → 9.0 (+29%)
- 데이터 무결성: 6.0 → 9.0 (+50%)

**종합 점수: 6.9 → 8.6 (+24% 향상)**

### 5-2. 최종 권장사항

✅ **명세서 적용을 강력히 권장합니다.**

**이유:**
1. 고객 경험 개선 효과가 큼 (코드 → 문장)
2. 결정 일관성 향상 (evidenceCount 기반)
3. 데이터 무결성 강화 (FAIL 처리)
4. 명세서 준수도 크게 향상

**주의사항:**
1. 단계적 적용 권장 (Phase 1 → 2 → 3)
2. 기존 데이터 호환성 확인
3. 테스트 커버리지 강화
4. 상위 레이어 에러 처리 대응

---

**작성일:** 2024년
**버전:** 1.0
**작성자:** AI Assistant




